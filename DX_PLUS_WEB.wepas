{@module
Author=DataExpress
Version=1.72.1 изменения в изменениях группы записей
HomePage=https://forum.mydataexpress.ru/viewtopic.php?f=16&t=3295
Description=Множество полезных вещей. Веб-версия.
@}

procedure DoCalcError(const Param: String; Row: Integer);
begin
  if Row > 0 then
    RaiseException(erCustomError, 'Ошибка вычисления выражения в параметре "' +
      Param + '" в строке ' + IntToStr(Row) + ': ' + ExceptionParam)
  else
    RaiseException(erCustomError, 'Ошибка вычисления выражения в параметре "' +
      Param + '": ' + ExceptionParam);
end;

procedure DoError(const Param: String; Row: Integer; const Msg: String);
begin
  if Row > 0 then
    RaiseException(erCustomError, 'Ошибка в параметре "' +
      Param + '" в строке ' + IntToStr(Row) + ': ' + Msg)
  else
    RaiseException(erCustomError, 'Ошибка в параметре "' +
      Param + '": ' + Msg);
end;

procedure DoSetFieldError(const Param: String; Row: Integer; V: Variant);
begin
  DoError(Param, Row, 'Результат вычисления выражения несовместим с типом поля. ' +
    'Результат выражения: ' + VarToStr(V));
end;

function TryEvalExpr(const Expr: String; Fm: TdxForm; const Param: String; Row: Integer): Variant;
begin
  try
    Result := Session.EvalExpr(Expr, Fm);
  except
    DoCalcError(Param, Row);
  end;
end;

function EvalRecId(const Expr: String; Fm: TdxForm): Variant;
begin
  try
    Result := Session.EvalExpr(Expr, Fm);
  except
    DoCalcError('Найти запись по ID', 0);
  end;

  if (Result <> Null) and not (VarType(Result) in [varInteger, varDouble]) then
    DoError('Найти запись по ID', 0, 'Некорректное вычисление идентификатора записи. ' +
      'Идентификатор записи должен быть целым числом. Текущий результат выражения: ' +
      VarToStr(Result));
end;

procedure RefreshQuery(Q: TdxQueryGrid; KeepPos: Boolean);
var
  RecId, RecNo: Integer;
begin
  if KeepPos then
  begin
    if Q.Editable then RecId := Q.RecId
    else RecNo := Q.RecNo;
  end;
  Q.Refresh;
  if RecId > 0 then Q.GotoRecord(RecId)
  else if RecNo > 0 then Q.MoveTo(RecNo);
end;

{@action
id=ECCE8FF5-BCAB-40B2-8F36-ED002A3A131B
@}

type
  TEventType = (evAfterPost, evDestroy);
  TEventSet = set of TEventType;

  TArfData = record
    Fm, MainFm: TdxForm;
    OldAfterPost, OldDestroy: TNotifyEvent;
    ObjName: String;
    Events: TEventSet;
  end;

var
  ArfArr: array of TArfData;

function FindArfData(Fm: TObject; Ev: TEventType): Integer;
var
  i: Integer;
begin
  for i := High(ArfArr) downto 0 do
    if (ArfArr[i].Fm = Fm) and not (Ev in ArfArr[i].Events) then
    begin
      Result := i;
      Exit;
    end;
  RaiseException(erCustomError, 'Форма не найдена.');
end;

procedure FormAfterPost(Sender: TObject);
var
  n: Integer;
begin
  n := FindArfData(Sender, evAfterPost);
  with ArfArr[n] do
  begin
    Include(Events, evAfterPost);
    try
      if OldAfterPost <> nil then OldAfterPost(Sender);
    finally
      Exclude(Events, evAfterPost);
    end;
    if MainFm.State in [dsInsert, dsEdit] then
    begin
      MainFm[ObjName] := Fm.RecId;
      MainFm.ActionResult := True;
    end;
  end;
end;

procedure FormDestroy(Sender: TObject);
var
  n: Integer;
begin
  n := FindArfData(Sender, evAfterPost);
  with ArfArr[n] do
  begin
    Fm := nil;
    Include(Events, evDestroy);
    try
      if OldDestroy <> nil then OldDestroy(Sender);
    finally
      Exclude(Events, evDestroy);
    end;
  end;
end;

function AddRecordToForm(const FormName: String; Values: TVariantArray2d;
  IgnoreAccess: Boolean; const ObjName, QueryName: String): Boolean;
var
  i, n: Integer;
  FlNm, Expr: String;
  Vl: Variant;
  Fm: TdxForm;
  Arf: TArfData;
begin
  Result := False;
  Fm := Session.CreateForm(FormName);
  if not IgnoreAccess and (Fm.CanAppend <> asOk) then
  begin
    Self.MessageDlg('Внимание', 'Недостаточно прав для добавления записи.', mtWarning, [mbOk], nil);
    Fm.Free;
    Exit;
  end;
  Fm.OpenRecord(0);
  Fm.Append;
  for i := 0 to High(Values) do
  begin
    FlNm := Values[i][0];
    Expr := Values[i][1];
    Vl := TryEvalExpr(Expr, Self, 'Вставить значения', i+1);
    try
      Fm[FlNm] := Vl;
    except
      Fm.Free;
      DoSetFieldError('Вставить значения', i+1, Vl);
    end;
  end;

  if ObjName <> '' then
  begin
    Arf.Fm := Fm;
    Arf.MainFm := Self;
    Arf.ObjName := ObjName;
    Arf.OldAfterPost := Fm.OnAfterPost;
    Arf.OldDestroy := Fm.OnDestroy;
    Fm.OnAfterPost := @FormAfterPost;
    Fm.OnDestroy := @FormDestroy;

    n := Length(ArfArr);
    SetLength(ArfArr, n + 1);
    ArfArr[n] := Arf;
  end;

  Self.GotoForm(FormName, Fm.RecId, False);
  Result := False;
end;

{@action
id=E30DB736-3D71-4710-A25A-53525B5425E4
@}

function EditRecordForm(const FormName, RecIdExpr: String; IgnoreAccess: Boolean;
  const ObjName, QueryName: String): Boolean;
var
  RId: Variant;
  acc: TAccessStatus;
  Fm: TdxForm;
  Arf: TArfData;
  n: Integer;
begin
  Result := False;
  RId := EvalRecId(RecIdExpr, Self);
  if RId = Null then Exit;
  Fm := Session.CreateForm(FormName);
  Fm.OpenRecord(RId);
  if Fm.RecordCount = 0 then
  begin
    Fm.Free;
    Exit;
  end;
  if not IgnoreAccess then
  begin
    acc := Fm.CanEdit;
    if acc = asCantEdit then
    begin
      Self.MsgBox('Внимание', 'Недостаточно прав для редактирования записи.');
      Fm.Free;
      Exit;
    end;
  end;
  Fm.Edit;
  Self.GotoForm(FormName, RId, False);
  Result := True;

  if ObjName <> '' then
  begin
    Arf.Fm := Fm;
    Arf.MainFm := Self;
    Arf.ObjName := ObjName;
    Arf.OldAfterPost := Fm.OnAfterPost;
    Arf.OldDestroy := Fm.OnDestroy;
    Fm.OnAfterPost := @FormAfterPost;
    Fm.OnDestroy := @FormDestroy;

    n := Length(ArfArr);
    SetLength(ArfArr, n + 1);
    ArfArr[n] := Arf;
  end;
end;

{@action
id=07F8A419-4FA7-4181-9529-073557E315CC
@}

type
  TSrfData = record
    Fm: TdxForm;
    OldShowForm: TNotifyEvent;
  end;

var
  SrfArr: array of TSrfData;

function FindSrfData(Sender: TObject): Integer;
var
  i: Integer;
begin
  for i := High(SrfArr) downto 0 do
  begin
    if SrfArr[i].Fm = Sender then
    begin
      Result := i;
      Exit;
    end;
  end;
  RaiseException(erCustomError, 'FindSrfData - форма не найдена.');
end;

procedure SrfShowForm(Sender: TObject);
var
  n: Integer;
begin
  n := FindSrfData(Sender);
  with SrfArr[n] do
  begin
    if OldShowForm <> nil then OldShowForm(Sender);
    Fm.Cancel;
  end;
end;

function ShowRecordForm(const FormName, RecIdExpr: String): Boolean;
var
  RId: Variant;
  n: Integer;
  Srf: TSrfData;
begin
  Result := False;
  RId := EvalRecId(RecIdExpr, Self);
  if RId = Null then Exit;
  Srf.Fm := Session.CreateForm(FormName);
  Srf.OldShowForm := Srf.Fm.OnShowForm;
  with Srf.Fm do
  begin
    OpenRecord(RId);
    if RecordCount = 0 then
    begin
      Free;
      Exit;
    end;
    OnShowForm := @SrfShowForm;
    Self.GotoForm(FormName, RId, False);
    Result := True;
  end;
  n := Length(SrfArr);
  SetLength(SrfArr, n + 1);
  SrfArr[n] := Srf;
end;

{@action
id=3C3908DD-0725-493B-98BE-CDE84D76FA74
@}

type
  TDrfData = record
    FormName, Filter: String;
    SelfFm: TdxForm;
  end;

var
  Drf: TDrfData;

function InnerDeleteRecordsForm: Integer;
begin
  with Session.CreateForm(Drf.FormName) do
  try
    try
      OpenRecords(Drf.Filter, Drf.SelfFm, False);
    except
      DoCalcError('Фильтр', 0)
    end;
    while not Eof do
    begin
      if Delete <> asOk then
        MoveNext;
    end;
    Result := RecordCount;
  finally
    Free;
  end;
end;

procedure DeleteRecordsMsgDlg(Sender: TObject; Bn: TMsgDlgBtn);
begin
  if Bn = mbYes then TdxForm(Sender).ActionResult := InnerDeleteRecordsForm
  else TdxForm(Sender).ActionResult := -1;
end;

function DeleteRecordsForm(const FormName, AFilter, Prompt: String): Integer;
begin
  Drf.FormName := FormName;
  Drf.Filter := AFilter;
  Drf.SelfFm := Self;

  if Prompt <> '' then
    Self.MessageDlg('Внимание', Prompt, mtConfirmation, [mbYes, mbNo], @DeleteRecordsMsgDlg)
  else
    Result := InnerDeleteRecordsForm;
end;

{@action
id=27127C44-FC1E-4442-AA90-D1EDEC354917
@}

procedure QueryRefresh(const QueryName: String; KeepPos: Boolean);
begin
  RefreshQuery(Self.Queries[QueryName], KeepPos);
end;

{@action
id=00CB2FAB-247E-4B84-BBD3-380E773E30E6
@}

function BeginAppendRecordToForm(Fm: TdxForm; IgnoreAccess: Boolean): Boolean;
var
  acc: TAccessStatus;
begin
  Result := False;
  if Fm.State in [dsInsert, dsEdit] then
  begin
    if Fm.Validate then Fm.Post
    else Exit;
  end;
  if not IgnoreAccess then acc := Fm.CanAppend;
  if IgnoreAccess or (acc = asOk) then acc := Fm.Append;
  if acc = asCantAppend then
  begin
    if (Fm.ParentForm = nil) or ((Fm.ParentForm <> nil) and
      (Fm.ParentForm.State in [dsInsert, dsEdit])) then
      Fm.MsgBox('Внимание', 'Недостаточно прав для добавления записи.');
  end;
  Result := acc = asOk;
  {if Result then
    Fm.GotoForm(Fm.FormCaption, Fm.RecId)}
end;

function BeginAppendToCurrentForm(IgnoreAccess: Boolean): Boolean;
begin
  Result := BeginAppendRecordToForm(Self, IgnoreAccess);
end;

{@action
id=CC3AFFA9-C0C0-40B3-AA60-02E08C0CC92E
@}

function PostFormData(Fm: TdxForm): Boolean;
begin
  if Fm.State in [dsInsert, dsEdit] then
  begin
    Result := Fm.Validate;
    if Result then
    begin
      Fm.Post;
      {Fm.GotoForm(Fm.FormCaption, Fm.RecId);}
    end;
  end
  else
    Result := True;
end;

function PostCurrentForm: Boolean;
begin
  Result := PostFormData(Self);
end;

{@action
id=4F5BF78B-863C-4134-8948-0C0247FA813D
@}

procedure CancelChangesForm(Fm: TdxForm);
begin
  if Fm.State in [dsInsert, dsEdit] then
  begin
    Fm.Cancel;
    {Fm.GotoForm(Fm.FormCaption, Fm.RecId);}
  end;
end;

procedure CancelChangesCurrentForm;
begin
  CancelChangesForm(Self);
end;

{@action
id=029B8BA9-5782-4A99-9EE5-B68BDD2099F4
@}

function BeginEditForm(Fm: TdxForm; IgnoreAccess: Boolean): TAccessStatus;
begin
  if Fm.State in [dsInsert, dsEdit] then
  begin
    Result := asOk;
    Exit;
  end;

  Result := Fm.CanEdit;
  case Result of
    asCantEdit:
      if (Fm.ParentForm = nil) or ((Fm.ParentForm <> nil) and (Fm.ParentForm.State in [dsInsert, dsEdit])) then
      begin
        if IgnoreAccess then Result := asOk
        else Fm.MsgBox('Внимание', 'Недостаточно прав для редактирования записи.');
      end;
  end;
  if Result = asOk then
    Result := Fm.Edit;
end;

function BeginEditCurrentForm(IgnoreAccess: Boolean): Boolean;
begin
  Result := BeginEditForm(Self, IgnoreAccess) = asOk;
end;

{@action
id=A4578B0A-604E-4BBA-8586-E511CEEA58CC
@}

function InsertValuesToFieldsOfCurrentForm(FieldValues: TVariantArray2d; IgnoreAccess, SaveRec: Boolean): Boolean;
var
  i: Integer;
  V: Variant;
  acc: TAccessStatus;
begin
  Result := False;
  if not (Self.State in [dsInsert, dsEdit]) then
  begin
    acc := BeginEditForm(Self, IgnoreAccess);
    if acc <> asOk then Exit;
  end;

  for i := 0 to High(FieldValues) do
  begin
    V := TryEvalExpr(FieldValues[i][1], Self, 'Вставить значения', i+1);
    try
      Self[ FieldValues[i][0] ] := V;
    except
      DoSetFieldError('Вставить значения', i+1, V);
    end;
  end;
  if SaveRec then
  begin
    Result := Self.Validate;
    if Result then Self.Post;
  end
  else Result := True;
end;

{@action
id=7D720030-6024-479A-BA31-A6C1CF8D379F
@}

function MoveToRecordCurrentForm(const MoveToRec: String; BeginEdit, IgnoreAccess: Boolean): Boolean;
var
  acc: TAccessStatus;
begin
  if Self.State in [dsInsert, dsEdit] then
  begin
    Result := Self.Validate;
    if Result then Self.Post
    else Exit;
  end;

  case MoveToRec of
    'Первую запись': Self.MoveFirst;
    'Последнюю запись': Self.MoveLast;
    'Предыдущую запись': Self.MovePrior;
    'Следующую запись': Self.MoveNext;
  end;

  if BeginEdit then
  begin
    acc := BeginEditForm(Self, IgnoreAccess);
    Result := acc = asOk;
  end
  else Result := True;
end;

{@action
id=E67BBB9B-D21B-4463-B99F-CC081E38893C
@}

var
  DelRecIgnoreAccess: Boolean;

function DeleteRecordForm(Fm: TdxForm; IgnoreAccess: Boolean): Boolean;
var
  acc: TAccessStatus;
begin
  if not IgnoreAccess then acc := Fm.CanDelete;
  if IgnoreAccess or (acc = asOk) then
  begin
    if Fm.State = dsInsert then
    begin
      Fm.Cancel;
      Result := True;
    end
    else
    begin
      if Fm.State = dsEdit then Fm.Cancel;
      Result := Fm.Delete = asOk;
    end;
  end;
  case acc of
    asCantDelete:
      Fm.MsgBox('Внимание', 'Недостаточно прав для удаления записи.');
    asModified:
      Fm.GotoForm(Fm.FormCaption, Fm.RecId, False);
    asDeleted:
      Fm.GotoForm(Fm.FormCaption, Fm.RecId, False);
    asLocked:
      Fm.MsgBox('Внимание', 'Невозможно удалить запись. Запись редактируется пользователем "' + Fm.WhoEdit(Fm.RecId) + '".');
    asHasRef:
      Fm.MsgBox('Внимание', 'Невозможно удалить запись, т. к. на нее есть ссылки в других формах.');
  end;
end;

procedure DeleteRecordMsgBtnClick(Sender: TObject; Btn: TMsgDlgBtn);
begin
  if Btn = mbYes then
  begin
    DeleteRecordForm(TdxForm(Sender), DelRecIgnoreAccess);
    TdxForm(Sender).ActionResult := True;
  end;
end;

function DeleteRecordCurrentForm(Prompt, IgnoreAccess: Boolean): Boolean;
begin
  Result := False;
  if (Self.ParentForm <> nil) and  not (Self.ParentForm.State in [dsInsert, dsEdit]) then Exit
  else if Prompt then
  begin
    Self.MessageDlg('Внимание', 'Вы точно хотите удалить запись?', mtConfirmation,
      [mbYes, mbNo], @DeleteRecordMsgBtnClick);
    DelRecIgnoreAccess := IgnoreAccess;
  end
  else Result := DeleteRecordForm(Self, IgnoreAccess);
end;

{@action
id=68F6220C-C814-4994-8D03-E2D9A95BB50D
@}

var
  ClearTableName: String;
  ClearTableIgnoreAccess: Boolean;

function InnerClearTable(Fm: TdxForm; TableName: String; IgnoreAccess: Boolean): Boolean;
var
  Tbl: TdxForm;
  RId: Integer;
  CanDelete: Boolean;
begin
  Result := False;
  Tbl := Fm.Forms[TableName];
  if Tbl.State in [dsInsert, dsEdit] then Tbl.Cancel;
  CanDelete := True;
  if not IgnoreAccess then
  begin
    RId := Tbl.RecId;
    Tbl.DisableScrollEvents;
    Tbl.MoveFirst;
    while not Tbl.Eof do
    begin
      if Tbl.CanDelete = asCantDelete then
      begin
        CanDelete := False;
        Break;
      end;
      Tbl.MoveNext;
    end;
    Tbl.GotoRecord(RId);
    Tbl.EnableScrollEvents;
  end;
  if not CanDelete then
  begin
    Fm.MsgBox('Внимание', 'Недостаточно прав для очистки таблицы.');
    Exit;
  end;

  while Tbl.RecordCount > 0 do
    Tbl.Delete;

  Result := True;
end;

procedure ClearTableMsgBtnClick(Sender: TObject; Btn: TMsgDlgBtn);
begin
  if Btn = mbYes then
  begin
    InnerClearTable(TdxForm(Sender), ClearTableName, ClearTableIgnoreAccess);
    TdxForm(Sender).ActionResult := True;
  end;
end;

function ClearTable(const TableName, Prompt: String; IgnoreAccess: Boolean): Boolean;
begin
  Result := False;
  if not (Self.State in [dsInsert, dsEdit]) then Exit;
  if Prompt <> '' then
  begin
    ClearTableName := TableName;
    ClearTableIgnoreAccess := IgnoreAccess;
    Self.MessageDlg('Внимание', Prompt, mtWarning, [mbYes, mbNo], @ClearTableMsgBtnClick);
  end
  else
    Result := InnerClearTable(Self, TableName, IgnoreAccess);
end;

{@action
id=715F1733-6C6D-4CCF-BA1E-A547EA6D87E1
@}

function AppendRecordToTable(const TblName: String; Values: TVariantArray2d;
  const ActionAfter: String; IgnoreAccess: Boolean): Boolean;
var
  Tbl: TdxForm;
  i: Integer;
  acc: TAccessStatus;
  V: Variant;
begin
  Result := False;
  if not (Self.State in [dsInsert, dsEdit]) then Exit;

  Tbl := Self.Forms[TblName];
  if IgnoreAccess then acc := asOk
  else acc := Tbl.CanAppend;

  if acc = asOk then
  begin
    if Tbl.State in [dsInsert, dsEdit] then
    begin
      if Tbl.Validate then Tbl.Post
      else
      begin
        Self.Msgs := Tbl.Msgs;
        Exit;
      end;
    end;

    Tbl.Append;
    for i := 0 to High(Values) do
    begin
      V := TryEvalExpr(Values[i][1], Self, 'Вставить значения', i+1);
      try
        Tbl[ Values[i][0] ] := V;
      except
        Tbl.Cancel;
        DoSetFieldError('Вставить значения', i+1, V);
      end;
    end;

    if ActionAfter = 'Показать окно редактирования' then
      Self.GotoForm(Tbl.FormCaption, Tbl.RecId, False)
    else if ActionAfter = 'Сохранить запись' then
    begin
      if Tbl.Validate then
      begin
        Tbl.Post;
        Result := True;
      end
      else
      begin
        Tbl.Cancel;
        Self.Msgs := Tbl.Msgs;
      end;
    end
    else
      Result := True;
  end
  else if acc = asCantAppend then
    Self.MsgBox('Внимание', 'Недостаточно прав для добавления записи.');
end;

{@action
id=94911265-5D75-417C-8EEF-1EC34745169A
@}
function EditRecordToTable(const TblName: String; Values: TVariantArray2d;
  const ActionAfter: String; IgnoreAccess: Boolean): Boolean;
var
  Tbl: TdxForm;
  i: Integer;
  acc: TAccessStatus;
  V: Variant;
begin
  Result := False;
  if not (Self.State in [dsInsert, dsEdit]) then Exit;

  Tbl := Self.Forms[TblName];
  if Tbl.RecId = 0 then Exit;

  if IgnoreAccess then acc := asOk
  else acc := Tbl.CanEdit;

  if acc = asOk then
  begin
    if not (Tbl.State in [dsInsert, dsEdit]) then
      Tbl.Edit;

    for i := 0 to High(Values) do
    begin
      V := TryEvalExpr(Values[i][1], Tbl, 'Вставить значения', i+1);
      try
        Tbl[ Values[i][0] ] := V;
      except
        Tbl.Cancel;
        DoSetFieldError('Вставить значения', i+1, V);
      end;
    end;

    if ActionAfter = 'Показать окно редактирования' then
      Self.GotoForm(Tbl.FormCaption, Tbl.RecId, False)
    else if ActionAfter = 'Сохранить запись' then
    begin
      if Tbl.Validate then
      begin
        Tbl.Post;
        Result := True;
      end
      else
      begin
        Tbl.Cancel;
        Self.Msgs := Tbl.Msgs;
      end;
    end
    else
      Result := True;
  end
  else if acc = asCantEdit then
    Self.MsgBox('Внимание', 'Недостаточно прав для изменения записи.');
end;

{@action
id=CD068F97-1AB9-4022-A425-7098F23F7856
@}

var
  DrtTbl: TdxForm;
  DrtIgnoreAccess: Boolean;

function InnerDeleteRecordFromTable(Fm, Tbl: TdxForm; IgnoreAccess: Boolean): Boolean;
var
  acc: TAccessStatus;
begin
  acc := Tbl.CanDelete;
  if IgnoreAccess or (Tbl.State = dsInsert) or (acc = asOk) then
  begin
    Result := True;
    Tbl.Delete;
  end
  else if acc = asCantDelete then
    Fm.MsgBox('Внимание', 'Недостаточно прав для удаления записи.');
end;

procedure DrtMsgBtnClick(Sender: TObject; Btn: TMsgDlgBtn);
begin
  if Btn = mbYes then
    TdxForm(Sender).ActionResult := InnerDeleteRecordFromTable(TdxForm(Sender),
      DrtTbl, DrtIgnoreAccess);
end;

function DeleteRecordFromTable(const TblName, Prompt: String; IgnoreAccess: Boolean): Boolean;
var
  Tbl: TdxForm;
begin
  Result := False;
  Tbl := Self.Forms[TblName];
  if not (Self.State in [dsInsert, dsEdit]) then Exit;
  if Tbl.RecId = 0 then Exit;
  if Prompt <> '' then
  begin
    DrtTbl := Tbl;
    DrtIgnoreAccess := IgnoreAccess;
    Self.MessageDlg('Внимание', Prompt, mtWarning, [mbYes, mbNo], @DrtMsgBtnClick);
  end
  else
    Result := InnerDeleteRecordFromTable(Self, Tbl, IgnoreAccess);
end;

{@action
id=8D8123AE-0A6C-4349-9152-F9399322BE50
@}

type
  TCrtData = record
    Tbl: TdxForm;
    Values: TVariantArray2d;
    Filter: String;
  end;

var
  CrtData: TCrtData;

function InnerChangeRecordsInTable(Fm, Tbl: TdxForm; Values: TVariantArray2d;
  const Filter: String): Boolean;
var
  RecId, i: Integer;
  V: Variant;
begin
  if Tbl.State in [dsInsert, dsEdit] then
  begin
    if Tbl.Validate then
      Tbl.Post
    else
    begin
      Fm.Msgs := Tbl.Msgs;
      Exit;
    end;
  end;

  RecId := Tbl.RecId;      //здесь номер строки таблицы
  Tbl.DisableScrollEvents;
  Tbl.MoveFirst;

  try

  while not Tbl.Eof do
  begin
    if Filter <> '' then
    begin
      V := TryEvalExpr(Filter, Tbl, 'Фильтр', 0);
      if (V <> Null) and (VarType(V) <> varboolean) then
        DoError('Фильтр', 0, 'Результат вычисления выражения фильтра не ' +
          'является булевым значением (True или False). Результат выражения: ' +
          VarToStr(V));
    end
    else
      V := Null;

    if (V = Null) or (V = True) then
    begin
      Tbl.Edit;
      for i := 0 to High(Values) do
      begin
        V := TryEvalExpr(Values[i][1], Tbl, 'Вставить значения', i+1);
        try
          Tbl[ Values[i][0] ] := V;
        except
          Tbl.Cancel;
          DoSetFieldError('Вставить значения', i+1, V);
        end;
      end;
      Tbl.Post;
    end;
    Tbl.MoveNext;
  end;
  Tbl.GotoRecord(RecId); //чтобы вернуться на запись
  Result := True;

  finally
    // Если возникла ошибка в вычислениях запись не будет сохранена
    if Tbl.State = dsEdit then Tbl.Cancel;
    //
    Tbl.GotoRecord(RecId);
    Tbl.EnableScrollEvents;
  end;
end;

procedure CrtMsgBtnClick(Sender: TObject; Btn: TMsgDlgBtn);
begin
  if Btn = mbYes then
    TdxForm(Sender).ActionResult := InnerChangeRecordsInTable(TdxForm(Sender),
      CrtData.Tbl, CrtData.Values, CrtData.Filter);
end;

function ChangeRecordsInTable(const TblName: String; Values: TVariantArray2d;
  const Filter, Prompt: String): Boolean;
var
  Tbl: TdxForm;
begin
  Result := False;
  Tbl := Self.Forms[TblName];
  if not (Self.State in [dsInsert, dsEdit]) then Exit;
  if Prompt <> '' then
  begin
    CrtData.Tbl := Tbl;
    CrtData.Values := Values;
    CrtData.Filter := Filter;
    Self.MessageDlg('Внимание', Prompt, mtWarning, [mbYes, mbNo], @CrtMsgBtnClick);
  end
  else
    Result := InnerChangeRecordsInTable(Self, Tbl, Values, Filter);
end;

{@action
id=A1039C22-88FA-4E7A-A030-FDBCED2E7D61
@}

type
  TFtqData = record
    Tbl: TdxForm;
    Qry: TdxQueryGrid;
    Fields: TVariantArray2d;
    NoClearTable: Boolean;
  end;

var
  Ftq: TFtqData;

function InnerFillTableFromQuery(Fm, Tbl: TdxForm; Qry: TdxQueryGrid; Fields: TVariantArray2d; NoClearTable: Boolean): Boolean;
var
  RecNo, i: Integer;
  FlNm, QFlNm, Expr: String;
  V: Variant;
begin
  RecNo := Qry.RecNo;
  Qry.DisableScrollEvents;

  try

    if NoClearTable = False then
      while not Tbl.Eof do
        Tbl.Delete;

    Qry.MoveFirst;
    while not Qry.Eof do
    begin
      Tbl.Append;
      for i := 0 to High(Fields) do
      begin
        FlNm := Fields[i][0];
        QFlNm := Fields[i][1];
        Expr := Fields[i][2];
        if QFlNm <> '' then
          try
            Tbl[FlNm] := Qry[QFlNm];
          except
            Tbl.Cancel;
            DoError('Поля', i+1,
              Format('Поля [%s] и [%s] несовместимы. Поля должны быть одного типа.',
                [FlNm, QFlNm]));
          end
        else if Expr <> '' then
        begin
          V := TryEvalExpr(Expr, Fm, 'Поля', i+1);
          try
            Tbl[FlNm] := V;
          except
            Tbl.Cancel;
            DoSetFieldError('Поля', i+1, V);
          end;
        end;
      end;
      Tbl.Post;
      Qry.MoveNext;
    end;
    Result := True;

  finally
    Tbl.MoveFirst;
    Qry.MoveTo(RecNo);
    Qry.EnableScrollEvents;
  end;
end;

procedure FtqMsgBtnClick(Sender: TObject; Btn: TMsgDlgBtn);
begin
  if Btn = mbYes then
    TdxForm(Sender).ActionResult := InnerFillTableFromQuery(TdxForm(Sender),
      Ftq.Tbl, Ftq.Qry, Ftq.Fields, Ftq.NoClearTable);
end;

function FillTableFromQuery(const TblName, QryName: String; Fields: TVariantArray2d;
  NoClearTable: Boolean; const Prompt: String): Boolean;
var
  Tbl: TdxForm;
  Qry: TdxQueryGrid;
begin
  Result := False;
  Tbl := Self.Forms[TblName];
  Qry := Self.Queries[QryName];
  if not (Self.State in [dsInsert, dsEdit]) then Exit;
  if Prompt <> '' then
  begin
    Ftq.Tbl := Tbl;
    Ftq.Qry := Qry;
    Ftq.Fields := Fields;
    Ftq.NoClearTable := NoClearTable;
    Self.MessageDlg('Внимание', Prompt, mtWarning, [mbYes, mbNo], @FtqMsgBtnClick);
  end
  else
    InnerFillTableFromQuery(Self, Tbl, Qry, Fields, NoClearTable);
end;

{@action
id=9A63F742-0950-4A2D-9C9B-68713311C76D
@}

type
  TSIQData = record
    Qry: TdxQueryGrid;
    AfterScroll, DestroyForm: TNotifyEvent;
    QFm, Fm: TdxForm;
    Fields: TVariantArray2d;
    Skip: Boolean;
  end;

var
  SIQArr: array of TSIQData;

function FindSIQData(Qry: TObject): Integer;
var
  i: Integer;
begin
  Result := -1;
  for i := High(SIQArr) downto 0 do
  begin
    if (SIQArr[i].Qry = Qry) and not SIQArr[i].Skip then
    begin
      Result := i;
      Exit;
    end;
  end;
end;

function FindSIQDataByForm(Fm: TObject): Integer;
var
  i: Integer;
begin
  Result := -1;
  for i := High(SIQArr) downto 0 do
  begin
    if (SIQArr[i].Fm = Fm) {and not SIQArr[i].Skip} then
    begin
      Result := i;
      Exit;
    end;
  end;
end;

procedure SIQ_QueryAfterScroll(Sender: TObject);
var
  i, id, n: Integer;
  QFm, Fm: TdxForm;
  St: TStream;
  Data: TSIQData;
  Img: TdxImage;
begin
  n := FindSIQData(Sender);
  if SIQArr[n].AfterScroll <> nil then
  try
    SIQArr[n].Skip := True;
    SIQArr[n].AfterScroll(Sender);
  finally
    SIQArr[n].Skip := False;
  end;

  id := SIQArr[n].Qry.RecId;
  Data := SIQArr[n];
  Fm := TdxForm(Data.Qry.Owner);

  for i := 0 to High(Data.Fields) do
  begin
    Img := TdxImage(Fm.FindComponent( Data.Fields[i][1] ));
    Img.Clear;
  end;

  QFm := Data.QFm;
  QFm.OpenRecord(id);
  if QFm.RecordCount > 0 then
  begin
    St := TMemoryStream.Create;

    for i := 0 to High(Data.Fields) do
    begin
      St.Size := 0;
      QFm.Images[ Data.Fields[i][0] ].SaveToStream(St);
      Img := TdxImage(Fm.FindComponent( Data.Fields[i][1] ));
      //Img.Clear;
      if St.Size > 0 then
      begin
        {Img.Center := True;
        Img.Proportional := True;
        Img.Stretch := True;
        Img.KeepSize := True;
        St.Position := 0;  }
        Img.LoadFromStream(St);
      end;
    end;

    St.Free;
  end;
  QFm.Close;
end;

procedure SIQ_DestroyFormHandler(Sender: TObject);
var
  i: Integer;
begin
  i := FindSIQDataByForm(Sender);
  with SIQArr[i] do
  begin
    QFm.Free;
    QFm := nil;
    Fm := nil;
    Qry := nil;
    if DestroyForm <> nil then DestroyForm(Sender);
  end;
end;

procedure ShowImageFromQuery(const QueryName, FormName: String; Fields: TVariantArray2d);
var
  n: Integer;
  Data: TSIQData;
begin
  Data.Qry := Self.Queries[QueryName];
  if not Data.Qry.Editable then
  begin
    Self.Msgs.Add('Запрос ' + QueryName + 'не является редактируемым.');
    Exit;
  end;
  Data.AfterScroll := Data.Qry.OnAfterScroll;
  Data.Qry.OnAfterScroll := @SIQ_QueryAfterScroll;
  Data.QFm := Session.CreateForm(FormName);
  Data.Fields := Fields;
  Data.Fm := Self;
  Data.DestroyForm := Self.OnDestroy;
  Self.OnDestroy := @SIQ_DestroyFormHandler;

  n := Length(SIQArr);
  SetLength(SIQArr, n+1);
  SIQArr[n] := Data;
end;

{@action
id=64B42EDB-518C-4E95-905F-01D0095ACE7F
@}

type
  TSVQData = record
    Qry: TdxQueryGrid;
    AfterScroll, DestroyForm: TNotifyEvent;
    Fm: TdxForm;
    Fields: TVariantArray2d;
    Skip: Boolean;
  end;

var
  SVQArr: array of TSVQData;

function FindSVQData(Qry: TObject): Integer;
var
  i: Integer;
begin
  Result := -1;
  for i := High(SVQArr) downto 0 do
  begin
    if (SVQArr[i].Qry = Qry) and not SVQArr[i].Skip then
    begin
      Result := i;
      Exit;
    end;
  end;
end;

function FindSVQDataByForm(Fm: TObject): Integer;
var
  i: Integer;
begin
  Result := -1;
  for i := High(SVQArr) downto 0 do
  begin
    if (SVQArr[i].Fm = Fm) {and not SVQArr[i].Skip} then
    begin
      Result := i;
      Exit;
    end;
  end;
end;

procedure SVQ_QueryAfterScroll(Sender: TObject);
var
  n, i: Integer;
  Data: TSVQData;
  QFlNm, CmpNm, FlNm: String;
  Cmp: TComponent;
begin
  n := FindSVQData(Sender);
  if SVQArr[n].AfterScroll <> nil then
  try
    SVQArr[n].Skip := True;
    SVQArr[n].AfterScroll(Sender);
  finally
    SVQArr[n].Skip := False;
  end;

  Data := SVQArr[n];
  if Data.Fm.State = dsBrowse then Exit;

  for i := 0 to High(Data.Fields) do
  begin
    QFlNm := Data.Fields[i][0];
    CmpNm := Data.Fields[i][1];
    Cmp := Data.Fm.FindComponent(CmpNm);
    if Cmp is TdxLabel then
      TdxLabel(Cmp).Caption := Data.Qry.AsS[QFlNm]
    else
    begin
      FlNm := GetComponentFieldName(Cmp);
      try
        Data.Fm[FlNm] := Data.Qry[QFlNm];
      except
        Data.Fm.MsgBox('Показать значение из запроса',
          Format('Поля [%s] и [%s] в строке %d несовместимы. Поля должны быть одного типа.',
            [QFlNm, FlNm, i+1]))
      end;
    end;
  end;
end;

procedure SVQ_DestroyFormHandler(Sender: TObject);
var
  i: Integer;
begin
  i := FindSVQDataByForm(Sender);
  with SVQArr[i] do
  begin
    Fm := nil;
    Qry := nil;
    if DestroyForm <> nil then DestroyForm(Sender);
  end;
end;

// Проверяем компоненты на дубли
procedure SVQ_CheckParams(var Fields: TVariantArray2d);
var
  SL: TStringList;
  i: Integer;
  Nm, Msg: String;
begin
  Msg := '';
  SL := TStringList.Create;
  for i := 0 to High(Fields) do
  begin
    Nm := Fields[i][1];
    if SL.IndexOf(Nm) < 0 then
      SL.Add(Nm)
    else
      Msg := Msg + LineEnding + Format('- В строке %d дублируется компонент [%s]', [i+1, Nm]);
  end;
  SL.Free;
  if Msg <> '' then
    DoError('Поля', 0, Msg);
end;

procedure ShowValueFromQuery(const QueryName: String; Fields: TVariantArray2d);
var
  Data: TSVQData;
  n: Integer;
begin
  SVQ_CheckParams(Fields);

  Data.Fm := Self;
  Data.DestroyForm := Self.OnDestroy;
  Self.OnDestroy := @SVQ_DestroyFormHandler;
  Data.Qry := Self.Queries[QueryName];
  Data.AfterScroll := Data.Qry.OnAfterScroll;
  Data.Qry.OnAfterScroll := @SVQ_QueryAfterScroll;
  Data.Fields := Fields;

  n := Length(SVQArr);
  SetLength(SVQArr, n + 1);
  SVQArr[n] := Data;
end;

{@action
id=8695A1F2-62B9-4A61-BF18-3858A0F1B9D7
@}

type
  TSIOData = record
    Fm, ObjFm: TdxForm;
    DestroyForm: TNotifyEvent;
    FieldChange: TFieldChangeEvent;
    Obj: TdxLookupComboBox;
    Fields: TVariantArray2d;
    Skip: Boolean;
  end;

var
  SIOArr: array of TSIOData;

function FindSIOData(Fm: TObject): Integer;
var
  i: Integer;
begin
  Result := -1;
  for i := High(SIOArr) downto 0 do
    if (SIOArr[i].Fm = Fm) and not SIOArr[i].Skip then
    begin
      Result := i;
      Exit;
    end;
end;

procedure SIO_FieldChange(Sender, Control: TObject; const FieldName: String);
var
  n, i: Integer;
  St: TStream;
  Img: TdxImage;
begin
  n := FindSIOData(Sender);
  with SIOArr[n] do
  begin

    if FieldChange <> nil then
    try
      Skip := True;
      FieldChange(Sender, Control, FieldName);
    finally
      Skip := False;
    end;

    if Control = Obj then
    begin
      if Fm[FieldName] = Null then
        for i := 0 to High(Fields) do
          TdxImage( Fm.FindComponent(Fields[i][1]) ).Clear
      else
      begin
        St := TMemoryStream.Create;
        ObjFm.OpenRecord(Fm[FieldName]);
        if ObjFm.RecordCount > 0 then
          for i := 0 to High(Fields) do
          begin
            Img := TdxImage( Fm.FindComponent(Fields[i][1]) );
            Img.Clear;
            St.Size := 0;
            ObjFm.Images[ Fields[i][0] ].SaveToStream(St);
            if St.Size > 0 then
            begin
              St.Position := 0;
              {Img.Center := True;
              Img.Stretch := True;
              Img.KeepSize := True;
              Img.Proportional := True;}
              Img.LoadFromStream(St);
            end;
          end;
        ObjFm.Close;
        St.Free;
      end;
    end;
  end;
end;

procedure SIO_DestroyFormHandler(Sender: TObject);
var
  i: Integer;
begin
  i := FindSIOData(Sender);
  with SIOArr[i] do
  begin
    Fm := nil;
    ObjFm.Free;
    if DestroyForm <> nil then DestroyForm(Sender);
  end;
end;

procedure ShowImageFromObject(const ObjName: String; Fields: TVariantArray2d);
var
  n: Integer;
  Data: TSIOData;
begin
  Data.Fm := Self;
  Data.DestroyForm := Self.OnDestroy;
  Self.OnDestroy := @SIO_DestroyFormHandler;
  Data.FieldChange := Self.OnFieldChange;
  Self.OnFieldChange := @SIO_FieldChange;
  Data.Obj := TdxLookupComboBox(Self.FindComponentByFieldName(ObjName));
  Data.ObjFm := Session.CreateForm(Data.Obj.SourceFormName);
  Data.Fields := Fields;

  n := Length(SIOArr);
  SetLength(SIOArr, n+1);
  SIOArr[n] := Data;
end;

{@action
id=49BDDFC2-FD4C-4945-9382-E70E33F37FE2
@}

type
  TCAPData = record
    Fm: TdxForm;
    AfterPost, BeforePost, DestroyForm: TNotifyEvent;
    Bn: TdxButton;
    Skip, IsBefore: Boolean;
  end;

var
  CAPArr: array of TCAPData;

function FindCAPData(Fm: TObject): Integer;
var
  i: Integer;
begin
  Result := -1;
  for i := High(CAPArr) downto 0 do
    if (CAPArr[i].Fm = Fm) and not CAPArr[i].Skip then
    begin
      Result := i;
      Exit;
    end;
end;

function FindCAPDataEx(Fm: TObject; IsBefore: Boolean): Integer;
var
  i: Integer;
begin
  Result := -1;
  for i := High(CAPArr) downto 0 do
    if (CAPArr[i].Fm = Fm) and (CAPArr[i].IsBefore = IsBefore) and not CAPArr[i].Skip then
    begin
      Result := i;
      Exit;
    end;
end;

procedure CAP_AfterPost(Sender: TObject);
var
  n: Integer;
begin
  n := FindCAPDataEx(Sender, False);
  with CAPArr[n] do
  begin
    if AfterPost <> nil then
    try
      Skip := True;
      AfterPost(Sender);
    finally
      Skip := False;
    end;

    Bn.Click;
  end;
end;

procedure CAP_BeforePost(Sender: TObject);
var
  n: Integer;
begin
  n := FindCAPDataEx(Sender, True);
  with CAPArr[n] do
  begin
    if BeforePost <> nil then
    try
      Skip := True;
      BeforePost(Sender);
    finally
      Skip := False;
    end;

    Bn.Click;
  end;
end;

procedure CAP_DestroyForm(Sender: TObject);
var
  n: Integer;
begin
  n := FindCAPData(Sender);
  with CAPArr[n] do
  begin
    Fm := nil;
    if DestroyForm <> nil then DestroyForm(Sender);
  end;
end;

procedure ClickOnPost(const BnName, When: String);
var
  Data: TCAPData;
  n: Integer;
begin
  Data.Fm := Self;
  Data.Bn := TdxButton(Self.FindComponent(BnName));
  if When = 'После сохранения' then
  begin
    Data.AfterPost := Self.OnAfterPost;
    Self.OnAfterPost := @CAP_AfterPost;
    Data.IsBefore := False;
  end
  else
  begin
    Data.BeforePost := Self.OnBeforePost;
    Self.OnBeforePost := @CAP_BeforePost;
    Data.IsBefore := True;
  end;
  Data.DestroyForm := Self.OnDestroy;
  Self.OnDestroy := @CAP_DestroyForm;

  n := Length(CAPArr);
  SetLength(CAPArr, n + 1);
  CAPArr[n] := Data;
end;

{@action
id=AB1F57AC-16B0-4128-BF70-39EC56063515
@}

type
  TCcfData = record
    Fm: TdxForm;
    FormDestroy, BeforeInsert, AfterInsert: TNotifyEvent;
    FieldChange: TFieldChangeEvent;
    Bn: TdxButton;
    Fields: array of TObject;
    Skip, SkipChange: Boolean;
  end;

var
  CcfArr: array of TCcfData;

function FindCcfData(Fm: TObject): Integer;
var
  i: Integer;
begin
  Result := -1;
  for i := High(CcfArr) downto 0 do
    if (CcfArr[i].Fm = Fm) and not CcfArr[i].Skip then
    begin
      Result := i;
      Exit;
    end;
end;

procedure Ccf_FormDestroy(Sender: TObject);
var
  n: Integer;
begin
  n := FindCcfData(Sender);
  with CcfArr[n] do
  begin
    Fm := nil;
    SetLength(Fields, 0);
    if FormDestroy <> nil then FormDestroy(Sender);
  end;
end;

procedure Ccf_FieldChange(Sender, Control: TObject; const FieldName: String);
var
  n: Integer;
  i: Integer;
begin
  n := FindCcfData(Sender);
  with CcfArr[n] do
  begin
    if FieldChange <> nil then
    try
      Skip := True;
      FieldChange(Sender, Control, FieldName);
    finally
      Skip := False;
    end;

    if not SkipChange then
      for i := 0 to High(Fields) do
        if Fields[i] = Control then
        begin
          Bn.Click;
          Break;
        end;
  end;
end;

procedure Ccf_AfterInsert(Sender: TObject);
var
  n: Integer;
begin
  n := FindCcfData(Sender);
  with CcfArr[n] do
  begin
    if AfterInsert <> nil then
    try
      Skip := True;
      AfterInsert(Sender);
    finally
      Skip := False;
    end;
    SkipChange := False;
  end;
end;

procedure Ccf_BeforeInsert(Sender: TObject);
var
  n: Integer;
begin
  n := FindCcfData(Sender);
  with CcfArr[n] do
  begin
    if BeforeInsert <> nil then
    try
      Skip := True;
      BeforeInsert(Sender);
    finally
      Skip := False;
    end;
    SkipChange := True;
  end;
end;

procedure ClickAfterChangeField(const BnName: String; Fields: TVariantArray2d);
var
  n, i: Integer;
  Data: TCcfData;
begin
  Data.Fm := Self;
  Data.Bn := TdxButton(Self.FindComponent(BnName));
  Data.FormDestroy := Self.OnDestroy;
  Data.FieldChange := Self.OnFieldChange;
  Data.BeforeInsert := Self.OnBeforeInsert;
  Data.AfterInsert := Self.OnAfterInsert;
  SetLength(Data.Fields, Length(Fields));
  for i := 0 to High(Fields) do
    Data.Fields[i] := Self.FindComponentByFieldName(Fields[i][0]);
  Data.Fm.OnDestroy := @Ccf_FormDestroy;
  Data.Fm.OnFieldChange := @Ccf_FieldChange;
  Data.Fm.OnBeforeInsert := @Ccf_BeforeInsert;
  Data.Fm.OnAfterInsert := @Ccf_AfterInsert;

  n := Length(CcfArr);
  SetLength(CcfArr, n + 1);
  CcfArr[n] := Data;
end;

{@action
id=8E1C0618-DC18-4F21-A621-456E55767869
@}

type
  TCaiData = record
    Fm: TdxForm;
    FormDestroy, AfterInsert, AfterScroll: TNotifyEvent;
    Bn: TdxButton;
    Skip, InsertFired: Boolean;
  end;

var
  CaiArr: array of TCaiData;

function FindCaiData(Fm: TObject): Integer;
var
  i: Integer;
begin
  Result := -1;
  for i := High(CaiArr) downto 0 do
    if (CaiArr[i].Fm = Fm) and not CaiArr[i].Skip then
    begin
      Result := i;
      Exit;
    end;
end;

procedure Cai_FormDestroy(Sender: TObject);
var
  n: Integer;
begin
  n := FindCaiData(Sender);
  with CaiArr[n] do
  begin
    Fm := nil;
    if FormDestroy <> nil then FormDestroy(Sender);
  end;
end;

procedure Cai_AfterScroll(Sender: TObject);
var
  n: Integer;
begin
  n := FindCaiData(Sender);
  with CaiArr[n] do
  begin
    if AfterScroll <> nil then
    try
      Skip := True;
      AfterScroll(Sender);
    finally
      Skip := False;
    end;
    if InsertFired then
    begin
      InsertFired := False;
      Bn.Click;
    end;
  end;
end;

procedure Cai_AfterInsert(Sender: TObject);
var
  n: Integer;
begin
  n := FindCaiData(Sender);
  with CaiArr[n] do
  begin
    if AfterInsert <> nil then
    try
      Skip := True;
      AfterInsert(Sender);
    finally
      Skip := False;
    end;
    InsertFired := True;
  end;
end;

procedure ClickAfterAppend(const BnName: String);
var
  n: Integer;
  Data: TCaiData;
begin
  Data.Fm := Self;
  Data.Bn := TdxButton(Self.FindComponent(BnName));
  Data.FormDestroy := Self.OnDestroy;
  Data.AfterInsert := Self.OnAfterInsert;
  Data.AfterScroll := Self.OnAfterScroll;
  Data.Fm.OnDestroy := @Cai_FormDestroy;
  Data.Fm.OnAfterInsert := @Cai_AfterInsert;
  Data.Fm.OnAfterScroll := @Cai_AfterScroll;

  n := Length(CaiArr);
  SetLength(CaiArr, n + 1);
  CaiArr[n] := Data;
end;

{@action
id=799C29C6-676F-44EE-A21C-F10DBF87CD0F
@}

procedure DisableQueryAutoRefresh(const QueryName: String);
begin
  Self.Queries[QueryName].ManualRefresh := True;
end;

{@action
id=C1B33196-B72E-40D8-88AA-E67659C0485B
@}

procedure EnableQueryAutoRefresh(const QueryName: String; RefreshQry, KeepPos: Boolean);
var
  Q: TdxQueryGrid;
begin
  Q := Self.Queries[QueryName];
  Q.ManualRefresh := False;
  RefreshQuery(Q, KeepPos);
end;

{@action
Id=35B8560B-A110-4BF9-B886-635E7BED9058
@}

type
  TArqData = record
    FormName: String;
    Qry: TdxQueryGrid;
    Fields: TVariantArray2d;
  end;

var
  Arq: TArqData;

function InnerAddRecordsFromQuery(SelfFm: TdxForm; const AFormName: String;
  Qry: TdxQueryGrid; AFields: TVariantArray2d): Variant;
var
  Fm: TdxForm;
  i, RecN: Integer;
  V: Variant;
  FmFl, QFl, Expr: String;
begin
  Fm := Session.CreateForm(AFormName);
  try
    RecN := Qry.RecNo;
    Qry.MoveFirst;
    Fm.OpenRecord(0);
    while not Qry.Eof do
    begin
      Fm.Append;
      for i := 0 to High(AFields) do
      begin
        FmFl := AFields[i][0];
        QFl := AFields[i][1];
        Expr := AFields[i][2];
        if QFl <> '' then
          try
            Fm[FmFl] := Qry[QFl];
          except
            Fm.Cancel;
            DoError('Сопоставление полей', i+1,
              Format('Поле формы [%s] и поле запроса [%s] несовместимы. Поля ' +
                'должны быть одного типа.', [FmFl, QFl]));
          end
        else if Expr <> '' then
        begin
          V := TryEvalExpr(Expr, SelfFm, 'Сопоставление полей', i+1);
          try
            Fm[FmFl] := V;
          except
            Fm.Cancel;
            DoSetFieldError('Сопоставление полей', i+1, V);
          end;
        end;
      end;
      Fm.Post;
      Qry.MoveNext;
    end;
    Result := True;
  finally
    Fm.Free;
    Qry.MoveTo(RecN);
  end;
end;

procedure ArqMsgBtnClick(Sender: TObject; Btn: TMsgDlgBtn);
begin
  if Btn = mbYes then
    TdxForm(Sender).ActionResult := InnerAddRecordsFromQuery(TdxForm(Sender),
      Arq.FormName, Arq.Qry, Arq.Fields);
end;

function AddRecordsFromQuery(const AFormName, AQueryName: String;
  AFields: TVariantArray2d; const AMsg: String): Variant;
var
  Qry: TdxQueryGrid;
begin
  Result := False;
  Qry := Self.Queries[AQueryName];
  if AMsg <> '' then
  begin
    Arq.FormName := AFormName;
    Arq.Qry := Qry;
    Arq.Fields := AFields;
    Self.MessageDlg('Внимание', AMsg, mtconfirmation, [mbYes, mbNo], @ArqMsgBtnClick)
  end
  else
    Result := InnerAddRecordsFromQuery(Self, AFormName, Qry, AFields);
end;

{@action
Id=C2B69DC1-2A0A-4AEF-8B70-3E22237C4FBE
@}

function OpenSimpleForm(const FormName, AOpenIn: String; AFields: TVariantArray2d): Variant;
var
  Fm: TdxForm;
  i: Integer;
  V: Variant;
begin
  Fm := Session.FindForm(FormName, 1);
  if Fm = nil then
  begin
    Fm := Session.CreateForm(FormName);
    Fm.OpenRecord(0);
    Fm.Append;
  end;
  for i := 0 to High(AFields) do
  begin
    V := TryEvalExpr(AFields[i][1], Self, 'Вставить значения', i+1);
    try
      Fm[ AFields[i][0] ] := V;
    except
      DoSetFieldError('Вставить значения', i+1, V);
    end;
  end;
  Self.GotoForm(FormName, 1, False);
  Result := True;
end;
